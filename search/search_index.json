{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pydantic-filters","text":"<p>Source Code: https://github.com/so-saf/pydantic-filters</p> <p>Describe the filters, not implement them!  A declarative and intuitive way to describe data filtering and sorting in your application.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Filtering by the models themselves as well as by related.</li> <li>Built-in pagination and sorting.</li> <li>Lots of settings and possible customizations.</li> <li>The only required dependency is Pydantic. You can use the basic features without being attached to specific frameworks,  or use one of the supported plugins and drivers: </li> <li>Plugins:<ul> <li>FastAPI &gt;= 0.100.0</li> </ul> </li> <li>Drivers: <ul> <li>SQLAlchemy &gt;= 2</li> </ul> </li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pydantic-filters\n</code></pre>"},{"location":"#a-simple-example","title":"A Simple Example","text":"<p><code>BaseFilter</code> is just a pydantic model, it should be treated similarly</p> <p>Let's imagine you have a simple user service with the following SQLAlchemy model:</p> <pre><code>from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    age: Mapped[int]\n</code></pre> <p>Describe how you would like to filter users using BaseFilter.</p> <pre><code>from typing import List\nfrom pydantic_filters import BaseFilter\n\n\nclass UserFilter(BaseFilter):\n    id: List[int]\n    name: List[str]\n    name__ilike: str\n    age__lt: int\n    age__gt: int\n</code></pre> <p><code>BaseFilter</code> is just a pydantic model, it should be treated similarly</p> <p>Next, you need to apply a filter to some query:</p> <pre><code>from sqlalchemy import select\nfrom pydantic_filters.drivers.sqlalchemy import append_filter_to_statement\n\nstatement = select(User)\nfilter_ = UserFilter(name__ilike=\"kate\", age__lt=23)\n\nstmt = append_filter_to_statement(\n    statement=statement, model=User, filter_=filter_,\n)\n</code></pre> <p>And get something like:</p> <pre><code>SELECT users.id, users.name, users.age \nFROM users \nWHERE users.name ILIKE 'kate' AND users.age &lt; 23\n</code></pre> <p>The filter can be used in conjunction with one of the supported web frameworks:</p> <pre><code>from typing import Annotated\nfrom fastapi import FastAPI, APIRouter\nfrom pydantic_filters.plugins.fastapi import FilterDepends\n\n\nrouter = APIRouter()\n\n\n@router.get(\"/\")\nasync def get_multiple(\n    filter_: Annotated[UserFilter, FilterDepends(UserFilter)],\n):\n    ...\n\n\napp = FastAPI(title=\"User Service\")\napp.include_router(router, prefix=\"/users\", tags=[\"User\"])\n</code></pre> <p></p>"},{"location":"api/drivers/sqlalchemy/","title":"SQLAlchemy","text":""},{"location":"api/drivers/sqlalchemy/#pydantic_filters.drivers.sqlalchemy.append_filter_to_statement","title":"append_filter_to_statement","text":"<pre><code>append_filter_to_statement(\n    statement: Select[_T], model: Type[_Model], filter_: _Filter\n) -&gt; Select[_T]\n</code></pre> <p>Append filtering to statement.</p> PARAMETER DESCRIPTION <code>statement</code> <p>Some select statement.</p> <p> TYPE: <code>Select[_T]</code> </p> <code>model</code> <p>Declaratively defined model.</p> <p> TYPE: <code>Type[_Model]</code> </p> <code>filter_</code> <p>Filter object.</p> <p> TYPE: <code>_Filter</code> </p> RAISES DESCRIPTION <code>AttributeNotFoundSaDriverError</code> <p>Attribute not found</p> <code>RelationshipNotFoundSaDriverError</code> <p>Relationship not found</p> Source code in <code>pydantic_filters/drivers/sqlalchemy/_main.py</code> <pre><code>def append_filter_to_statement(\n        statement: sa.Select[_T],\n        model: Type[_Model],\n        filter_: _Filter,\n) -&gt; sa.Select[_T]:\n    \"\"\"\n    Append filtering to statement.\n\n    Args:\n        statement: Some select statement.\n        model: Declaratively defined model.\n        filter_: Filter object.\n\n    Raises:\n        AttributeNotFoundSaDriverError: Attribute not found\n        RelationshipNotFoundSaDriverError:  Relationship not found\n    \"\"\"\n\n    join_targets = filter_to_join_targets(filter_, model)\n    for target in join_targets:\n        statement = statement.join(\n            target=target.target,\n            onclause=target.on_clause,\n        )\n\n    clauses = filter_to_column_clauses(filter_, model)\n    if clauses:\n        statement = statement.where(*clauses)\n\n    return statement\n</code></pre>"},{"location":"api/drivers/sqlalchemy/#pydantic_filters.drivers.sqlalchemy.append_pagination_to_statement","title":"append_pagination_to_statement","text":"<pre><code>append_pagination_to_statement(\n    statement: Select[_T], pagination: _Pagination\n) -&gt; Select[_T]\n</code></pre> <p>Append pagination to statement.</p> PARAMETER DESCRIPTION <code>statement</code> <p>Some select statement.</p> <p> TYPE: <code>Select[_T]</code> </p> <code>pagination</code> <p>Pagination object.</p> <p> TYPE: <code>_Pagination</code> </p> RAISES DESCRIPTION <code>AttributeNotFoundSaDriverError</code> <p>Attribute not found</p> Source code in <code>pydantic_filters/drivers/sqlalchemy/_main.py</code> <pre><code>def append_pagination_to_statement(\n        statement: sa.Select[_T],\n        pagination: _Pagination,\n) -&gt; sa.Select[_T]:\n    \"\"\"\n    Append pagination to statement.\n\n    Args:\n        statement: Some select statement.\n        pagination: Pagination object.\n\n    Raises:\n        AttributeNotFoundSaDriverError: Attribute not found\n    \"\"\"\n\n    return (\n        statement\n        .limit(pagination.get_limit())\n        .offset(pagination.get_offset())\n    )\n</code></pre>"},{"location":"api/drivers/sqlalchemy/#pydantic_filters.drivers.sqlalchemy.append_sort_to_statement","title":"append_sort_to_statement","text":"<pre><code>append_sort_to_statement(\n    statement: Select[_T], model: Type[_Model], sort: _Sort\n) -&gt; Select[_T]\n</code></pre> <p>Append sorting to statement.</p> PARAMETER DESCRIPTION <code>statement</code> <p>Some select statement.</p> <p> TYPE: <code>Select[_T]</code> </p> <code>model</code> <p>Declaratively defined model.</p> <p> TYPE: <code>Type[_Model]</code> </p> <code>sort</code> <p>Sort object.</p> <p> TYPE: <code>_Sort</code> </p> RAISES DESCRIPTION <code>AttributeNotFoundSaDriverError</code> <p>Attribute not found</p> Source code in <code>pydantic_filters/drivers/sqlalchemy/_main.py</code> <pre><code>def append_sort_to_statement(\n        statement: sa.Select[_T],\n        model: Type[_Model],\n        sort: _Sort,\n) -&gt; sa.Select[_T]:\n    \"\"\"\n    Append sorting to statement.\n\n    Args:\n        statement: Some select statement.\n        model: Declaratively defined model.\n        sort: Sort object.\n\n    Raises:\n        AttributeNotFoundSaDriverError: Attribute not found\n    \"\"\"\n\n    if sort.sort_by is None:\n        return statement\n\n    try:\n        column: sa.ColumnElement = getattr(model, str(sort.sort_by))\n    except AttributeError as e:\n        raise AttributeNotFoundSaDriverError(\n            f\"{sort.__class__.__name__}.sort_by: \"\n            f\"Column {model.__name__}.{sort.sort_by} not found\",\n        ) from e\n\n    return statement.order_by(\n        sa.desc(column) if sort.sort_by_order == SortByOrder.desc else sa.asc(column),\n    )\n</code></pre>"},{"location":"api/drivers/sqlalchemy/#pydantic_filters.drivers.sqlalchemy.append_to_statement","title":"append_to_statement","text":"<pre><code>append_to_statement(\n    statement: Select[_T],\n    model: Type[_Model],\n    *,\n    filter_: Optional[_Filter] = None,\n    sort: Optional[_Sort] = None,\n    pagination: Optional[_Pagination] = None\n) -&gt; Select[_T]\n</code></pre> <p>All in one function.</p> PARAMETER DESCRIPTION <code>statement</code> <p>Some select statement.</p> <p> TYPE: <code>Select[_T]</code> </p> <code>model</code> <p>Declaratively defined model.</p> <p> TYPE: <code>Type[_Model]</code> </p> <code>filter_</code> <p>Filter object.</p> <p> TYPE: <code>Optional[_Filter]</code> DEFAULT: <code>None</code> </p> <code>sort</code> <p>Sort object.</p> <p> TYPE: <code>Optional[_Sort]</code> DEFAULT: <code>None</code> </p> <code>pagination</code> <p>Pagination object.</p> <p> TYPE: <code>Optional[_Pagination]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>AttributeNotFoundSaDriverError</code> <p>Attribute not found</p> <code>RelationshipNotFoundSaDriverError</code> <p>Relationship not found</p> Source code in <code>pydantic_filters/drivers/sqlalchemy/_main.py</code> <pre><code>def append_to_statement(\n        statement: sa.Select[_T],\n        model: Type[_Model],\n        *,\n        filter_: Optional[_Filter] = None,\n        sort: Optional[_Sort] = None,\n        pagination: Optional[_Pagination] = None,\n) -&gt; sa.Select[_T]:\n    \"\"\"\n    All in one function.\n\n    Args:\n        statement: Some select statement.\n        model: Declaratively defined model.\n        filter_: Filter object.\n        sort: Sort object.\n        pagination: Pagination object.\n\n    Raises:\n        AttributeNotFoundSaDriverError: Attribute not found\n        RelationshipNotFoundSaDriverError:  Relationship not found\n    \"\"\"\n\n    if filter_ is not None:\n        statement = append_filter_to_statement(statement=statement, model=model, filter_=filter_)\n    if sort is not None:\n        statement = append_sort_to_statement(statement=statement, model=model, sort=sort)\n    if pagination is not None:\n        statement = append_pagination_to_statement(statement=statement, pagination=pagination)\n\n    return statement\n</code></pre>"},{"location":"api/drivers/sqlalchemy/#pydantic_filters.drivers.sqlalchemy.get_count_statement","title":"get_count_statement","text":"<pre><code>get_count_statement(model: Type[_Model], filter_: _Filter) -&gt; Select[_T]\n</code></pre> <p>Get count statement.</p> PARAMETER DESCRIPTION <code>model</code> <p>Declaratively defined model.</p> <p> TYPE: <code>Type[_Model]</code> </p> <code>filter_</code> <p>Filter object.</p> <p> TYPE: <code>_Filter</code> </p> RAISES DESCRIPTION <code>AttributeNotFoundSaDriverError</code> <p>Attribute not found.</p> <code>RelationshipNotFoundSaDriverError</code> <p>Relationship not found.</p> <code>SupportSaDriverError</code> <p>Composite primary keys are not supported.</p> Source code in <code>pydantic_filters/drivers/sqlalchemy/_main.py</code> <pre><code>def get_count_statement(\n        model: Type[_Model],\n        filter_: _Filter,\n) -&gt; sa.Select[_T]:\n    \"\"\"\n    Get count statement.\n\n    Args:\n        model: Declaratively defined model.\n        filter_: Filter object.\n\n    Raises:\n        AttributeNotFoundSaDriverError: Attribute not found.\n        RelationshipNotFoundSaDriverError:  Relationship not found.\n        SupportSaDriverError: Composite primary keys are not supported.\n    \"\"\"\n\n    primary_key: Tuple[sa.ColumnElement, ...] = sa.inspect(model).primary_key\n    if len(primary_key) &gt; 1:\n        raise SupportSaDriverError(\"Composite primary keys are not supported\")\n\n    statement = sa.select(\n        sa.func.count(\n            sa.distinct(primary_key[0]),\n        ),\n    )\n\n    return append_filter_to_statement(statement, model, filter_)\n</code></pre>"},{"location":"api/drivers/sqlalchemy/#pydantic_filters.drivers.sqlalchemy.BaseSaDriverError","title":"BaseSaDriverError","text":"<p>               Bases: <code>Exception</code></p> <p>Base SQLAlchemy driver error</p>"},{"location":"api/drivers/sqlalchemy/#pydantic_filters.drivers.sqlalchemy.AttributeNotFoundSaDriverError","title":"AttributeNotFoundSaDriverError","text":"<p>               Bases: <code>BaseSaDriverError</code></p>"},{"location":"api/drivers/sqlalchemy/#pydantic_filters.drivers.sqlalchemy.RelationshipNotFoundSaDriverError","title":"RelationshipNotFoundSaDriverError","text":"<p>               Bases: <code>BaseSaDriverError</code></p>"},{"location":"api/drivers/sqlalchemy/#pydantic_filters.drivers.sqlalchemy.SupportSaDriverError","title":"SupportSaDriverError","text":"<p>               Bases: <code>BaseSaDriverError</code></p> <p>Driver support error</p>"},{"location":"api/filter/base_filter/","title":"BaseFilter","text":""},{"location":"api/filter/base_filter/#pydantic_filters.BaseFilter","title":"BaseFilter","text":"<p>               Bases: <code>BaseModel</code></p> <p>A base class for creating pydantic-based filters.</p>"},{"location":"api/filter/base_filter/#pydantic_filters.BaseFilter.filter_fields","title":"filter_fields  <code>class-attribute</code>","text":"<pre><code>filter_fields: Dict[str, FilterFieldInfo]\n</code></pre> <p>Metadata about the filters fields defined on the model, mapping of field names to <code>FilterFieldInfo</code> objects.</p>"},{"location":"api/filter/base_filter/#pydantic_filters.BaseFilter.search_fields","title":"search_fields  <code>class-attribute</code>","text":"<pre><code>search_fields: Dict[str, SearchFieldInfo]\n</code></pre> <p>Metadata about the search fields defined on the model, mapping of field names to <code>SearchFieldInfo</code> objects.</p>"},{"location":"api/filter/base_filter/#pydantic_filters.BaseFilter.nested_filters","title":"nested_filters  <code>class-attribute</code>","text":"<pre><code>nested_filters: Dict[str, Type[BaseFilter]]\n</code></pre> <p>Metadata about the nested filters defined on the model, mapping of field names to <code>BaseFilter</code> objects.</p>"},{"location":"api/filter/base_filter/#pydantic_filters.BaseFilter.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = FilterConfigDict(\n    delimiter=\"__\",\n    optional=True,\n    default_filter_type=eq,\n    default_search_type=case_insensitive,\n    suffixes_map=get_suffixes_map(),\n    sequence_types=(list, set),\n)\n</code></pre> <p>Configuration for the model, should be a dictionary conforming to <code>FilterConfigDict</code>.</p>"},{"location":"api/filter/configuration/","title":"Configuration","text":""},{"location":"api/filter/configuration/#pydantic_filters.FilterConfigDict","title":"FilterConfigDict","text":"<p>               Bases: <code>ConfigDict</code></p> <p>A TypedDict for configuring filtering</p>"},{"location":"api/filter/configuration/#pydantic_filters.FilterConfigDict.delimiter","title":"delimiter  <code>instance-attribute</code>","text":"<pre><code>delimiter: str\n</code></pre> <p>A delimiter before the suffix.</p>"},{"location":"api/filter/configuration/#pydantic_filters.FilterConfigDict.optional","title":"optional  <code>instance-attribute</code>","text":"<pre><code>optional: bool\n</code></pre> <p>Make all fields optional</p>"},{"location":"api/filter/configuration/#pydantic_filters.FilterConfigDict.default_filter_type","title":"default_filter_type  <code>instance-attribute</code>","text":"<pre><code>default_filter_type: FilterType\n</code></pre> <p>Default filter type if not specified directly in <code>FilterField</code> or by suffix.</p>"},{"location":"api/filter/configuration/#pydantic_filters.FilterConfigDict.default_search_type","title":"default_search_type  <code>instance-attribute</code>","text":"<pre><code>default_search_type: SearchType\n</code></pre> <p>Default search type if not specified directly in <code>SearchField</code>.</p>"},{"location":"api/filter/configuration/#pydantic_filters.FilterConfigDict.suffixes_map","title":"suffixes_map  <code>instance-attribute</code>","text":"<pre><code>suffixes_map: Dict[str, FilterType]\n</code></pre> <p>Suffix mapping to filter type</p>"},{"location":"api/filter/configuration/#pydantic_filters.FilterConfigDict.sequence_types","title":"sequence_types  <code>instance-attribute</code>","text":"<pre><code>sequence_types: Tuple[Type, ...]\n</code></pre> <p>Types that are considered sequences</p>"},{"location":"api/filter/fields/","title":"Fields","text":""},{"location":"api/filter/fields/#pydantic_filters.FilterField","title":"FilterField","text":"<pre><code>FilterField(\n    default: Any = PydanticUndefined,\n    *,\n    target: Optional[str] = None,\n    type_: Union[FilterTypeLiteral, FilterType, None] = None,\n    **field_kwargs: Any\n) -&gt; FilterFieldInfo\n</code></pre> <p>Create a field for objects that can be configured.</p> <p>Used to provide extra information about a field.</p> PARAMETER DESCRIPTION <code>default</code> <p>Default value to be passed to pydantic.Field.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>PydanticUndefined</code> </p> <code>target</code> <p>Target for filtering.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>type_</code> <p>Filter type.</p> <p> TYPE: <code>Union[FilterTypeLiteral, FilterType, None]</code> DEFAULT: <code>None</code> </p> <code>**field_kwargs</code> <p>Other arguments to pass to pydantic.Field.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>pydantic_filters/filter/_fields.py</code> <pre><code>def FilterField(  # noqa: N802\n        default: Any = PydanticUndefined,  # noqa: ANN401\n        *,\n        target: Optional[str] = None,\n        type_: Union[FilterTypeLiteral, FilterType, None] = None,\n        **field_kwargs: Any,  # noqa: ANN003\n) -&gt; FilterFieldInfo:\n    \"\"\"\n    Create a field for objects that can be configured.\n\n    Used to provide extra information about a field.\n\n    Args:\n        default: Default value to be passed to pydantic.Field.\n        target: Target for filtering.\n        type_: Filter type.\n        **field_kwargs: Other arguments to pass to pydantic.Field.\n    \"\"\"\n\n    field_kwargs[\"default\"] = default\n    if type_ is not None:\n        type_ = FilterType(type_)\n\n    return FilterFieldInfo(\n        type_=type_,\n        target=target,\n        field_kwargs=field_kwargs,\n    )\n</code></pre>"},{"location":"api/filter/fields/#pydantic_filters.SearchField","title":"SearchField","text":"<pre><code>SearchField(\n    default: Any = PydanticUndefined,\n    *,\n    target: Sequence[str],\n    type_: Union[SearchTypeLiteral, SearchType, None] = None,\n    **field_kwargs: Any\n) -&gt; SearchFieldInfo\n</code></pre> <p>Create a field for objects that can be configured.</p> <p>Used to provide extra information about a field.</p> PARAMETER DESCRIPTION <code>default</code> <p>Default value to be passed to pydantic.Field.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>PydanticUndefined</code> </p> <code>target</code> <p>Target for search.</p> <p> TYPE: <code>Sequence[str]</code> </p> <code>type_</code> <p>Search type.</p> <p> TYPE: <code>Union[SearchTypeLiteral, SearchType, None]</code> DEFAULT: <code>None</code> </p> <code>**field_kwargs</code> <p>Other arguments to pass to pydantic.Field.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>pydantic_filters/filter/_fields.py</code> <pre><code>def SearchField(  # noqa: N802\n        default: Any = PydanticUndefined,  # noqa: ANN401\n        *,\n        target: Sequence[str],\n        type_: Union[SearchTypeLiteral, SearchType, None] = None,\n        **field_kwargs: Any,  # noqa: ANN003\n) -&gt; SearchFieldInfo:\n    \"\"\"\n    Create a field for objects that can be configured.\n\n    Used to provide extra information about a field.\n\n    Args:\n        default: Default value to be passed to pydantic.Field.\n        target: Target for search.\n        type_: Search type.\n        **field_kwargs: Other arguments to pass to pydantic.Field.\n    \"\"\"\n\n    field_kwargs[\"default\"] = default\n    if type_ is not None:\n        type_ = SearchType(type_)\n\n    return SearchFieldInfo(\n        type_=type_,\n        target=target,\n        field_kwargs=field_kwargs,\n    )\n</code></pre>"},{"location":"api/filter/fields/#pydantic_filters.filter._fields.FilterFieldInfo","title":"FilterFieldInfo","text":"<pre><code>FilterFieldInfo(\n    *,\n    target: Optional[str] = None,\n    type_: Optional[FilterType] = None,\n    is_sequence: Optional[bool] = None,\n    field_kwargs: Optional[Dict[str, Any]] = None\n)\n</code></pre> <p>               Bases: <code>BaseField</code></p> <p>This class holds information about a filter field.</p> <p>FilterFieldInfo is used for any filter field definition regardless of whether the <code>FilterField()</code> function is explicitly used.</p> Warning <p>You generally shouldn't be creating <code>FilterFieldInfo</code> directly, you'll only need to use it when accessing <code>BaseFilter</code>.filter_fields internals.</p> PARAMETER DESCRIPTION <code>target</code> <p>Target for filtering.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>type_</code> <p>Filter type.</p> <p> TYPE: <code>Optional[FilterType]</code> DEFAULT: <code>None</code> </p> <code>is_sequence</code> <p>Is the field annotated as sequence.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>field_kwargs</code> <p>Other arguments to pass to pydantic.Field.</p> <p> TYPE: <code>Optional[Dict[str, Any]]</code> DEFAULT: <code>None</code> </p> Source code in <code>pydantic_filters/filter/_fields.py</code> <pre><code>def __init__(\n        self,\n        *,\n        target: Optional[str] = None,\n        type_: Optional[FilterType] = None,\n        is_sequence: Optional[bool] = None,\n        field_kwargs: Optional[Dict[str, Any]] = None,\n) -&gt; None:\n    self.target = target\n    self.type = type_\n    self.is_sequence = is_sequence\n    super().__init__(\n        field_kwargs=field_kwargs,\n    )\n</code></pre>"},{"location":"api/filter/fields/#pydantic_filters.filter._fields.FilterFieldInfo.field_kwargs","title":"field_kwargs  <code>property</code>","text":"<pre><code>field_kwargs: Dict[str, Any]\n</code></pre> <p>Get arguments for pydantic.FieldInfo creating.</p>"},{"location":"api/filter/fields/#pydantic_filters.filter._fields.SearchFieldInfo","title":"SearchFieldInfo","text":"<pre><code>SearchFieldInfo(\n    *,\n    target: Sequence[str],\n    type_: Optional[SearchType] = None,\n    is_sequence: Optional[bool] = None,\n    field_kwargs: Optional[Dict[str, Any]] = None\n)\n</code></pre> <p>               Bases: <code>BaseField</code></p> <p>This class holds information about a search field.</p> <p>SearchFieldInfo is used for any search field definition regardless of whether the <code>SearchField()</code> function is explicitly used.</p> Warning <p>You generally shouldn't be creating <code>SearchFieldInfo</code> directly, you'll only need to use it when accessing <code>BaseFilter</code>.search_fields internals.</p> PARAMETER DESCRIPTION <code>target</code> <p>Target for search.</p> <p> TYPE: <code>Sequence[str]</code> </p> <code>type_</code> <p>Search type.</p> <p> TYPE: <code>Optional[SearchType]</code> DEFAULT: <code>None</code> </p> <code>is_sequence</code> <p>Is the field annotated as sequence.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>field_kwargs</code> <p>Other arguments to pass to pydantic.Field.</p> <p> TYPE: <code>Optional[Dict[str, Any]]</code> DEFAULT: <code>None</code> </p> Source code in <code>pydantic_filters/filter/_fields.py</code> <pre><code>def __init__(\n        self,\n        *,\n        target: Sequence[str],\n        type_: Optional[SearchType] = None,\n        is_sequence: Optional[bool] = None,\n        field_kwargs: Optional[Dict[str, Any]] = None,\n) -&gt; None:\n\n    if not target:\n        raise ValueError(\"Target must contain at least one value\")\n\n    self.target = target\n    self.type = type_\n    self.is_sequence = is_sequence\n    super().__init__(\n        field_kwargs=field_kwargs,\n    )\n</code></pre>"},{"location":"api/filter/fields/#pydantic_filters.filter._fields.SearchFieldInfo.field_kwargs","title":"field_kwargs  <code>property</code>","text":"<pre><code>field_kwargs: Dict[str, Any]\n</code></pre> <p>Get arguments for pydantic.FieldInfo creating.</p>"},{"location":"api/filter/types/","title":"Types","text":""},{"location":"api/filter/types/#pydantic_filters.FilterType","title":"FilterType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Type of filter operation.</p>"},{"location":"api/filter/types/#pydantic_filters.FilterType.eq","title":"eq  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eq = 'eq'\n</code></pre> <p>Equal</p>"},{"location":"api/filter/types/#pydantic_filters.FilterType.ne","title":"ne  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ne = 'ne'\n</code></pre> <p>Not equal</p>"},{"location":"api/filter/types/#pydantic_filters.FilterType.null","title":"null  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>null = 'null'\n</code></pre> <p>Is null</p>"},{"location":"api/filter/types/#pydantic_filters.FilterType.gt","title":"gt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gt = 'gt'\n</code></pre> <p>Grater than</p>"},{"location":"api/filter/types/#pydantic_filters.FilterType.ge","title":"ge  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ge = 'ge'\n</code></pre> <p>Grater than or equal</p>"},{"location":"api/filter/types/#pydantic_filters.FilterType.lt","title":"lt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lt = 'lt'\n</code></pre> <p>Lower than</p>"},{"location":"api/filter/types/#pydantic_filters.FilterType.le","title":"le  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>le = 'le'\n</code></pre> <p>Lower than or equal</p>"},{"location":"api/filter/types/#pydantic_filters.FilterType.like","title":"like  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>like = 'like'\n</code></pre> <p>Case-sensitive matching</p>"},{"location":"api/filter/types/#pydantic_filters.FilterType.ilike","title":"ilike  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ilike = 'ilike'\n</code></pre> <p>Case-insensitive matching</p>"},{"location":"api/filter/types/#pydantic_filters.filter.FilterTypeLiteral","title":"FilterTypeLiteral  <code>module-attribute</code>","text":"<pre><code>FilterTypeLiteral: TypeAlias = Literal[\n    \"eq\", \"ne\", \"null\", \"gt\", \"ge\", \"lt\", \"le\", \"like\", \"ilike\"\n]\n</code></pre> <p>Literal alias for <code>FilterType</code></p>"},{"location":"api/filter/types/#pydantic_filters.SearchType","title":"SearchType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Type of search operation.</p>"},{"location":"api/filter/types/#pydantic_filters.SearchType.case_sensitive","title":"case_sensitive  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>case_sensitive = 'case_sensitive'\n</code></pre> <p>Case sensitive</p>"},{"location":"api/filter/types/#pydantic_filters.SearchType.case_insensitive","title":"case_insensitive  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>case_insensitive = 'case_insensitive'\n</code></pre> <p>Case insensitive</p>"},{"location":"api/filter/types/#pydantic_filters.filter.SearchTypeLiteral","title":"SearchTypeLiteral  <code>module-attribute</code>","text":"<pre><code>SearchTypeLiteral: TypeAlias = Literal['case_sensitive', 'case_insensitive']\n</code></pre> <p>Literal alias for <code>SearchType</code></p>"},{"location":"api/filter/types/#pydantic_filters.filter._types._suffixes_map","title":"_suffixes_map  <code>module-attribute</code>","text":"<pre><code>_suffixes_map: Dict[str, FilterType] = {\n    \"eq\": eq,\n    \"n\": ne,\n    \"ne\": ne,\n    \"neq\": ne,\n    \"null\": null,\n    \"isnull\": null,\n    \"gt\": gt,\n    \"ge\": ge,\n    \"gte\": ge,\n    \"lt\": lt,\n    \"le\": le,\n    \"lte\": le,\n    \"l\": like,\n    \"like\": like,\n    \"il\": ilike,\n    \"ilike\": ilike,\n}\n</code></pre>"},{"location":"api/filter/types/#pydantic_filters.get_suffixes_map","title":"get_suffixes_map","text":"<pre><code>get_suffixes_map() -&gt; Dict[str, FilterType]\n</code></pre> <p>Returns the standard set of synonyms defined in <code>_suffixes_map</code></p> Source code in <code>pydantic_filters/filter/_types.py</code> <pre><code>def get_suffixes_map() -&gt; Dict[str, FilterType]:\n    \"\"\"\n    Returns the standard set of synonyms defined in\n    [`_suffixes_map`][pydantic_filters.filter._types._suffixes_map]\n    \"\"\"\n    return deepcopy(_suffixes_map)\n</code></pre>"},{"location":"api/pagination/pagination/","title":"Pagination","text":""},{"location":"api/pagination/pagination/#pydantic_filters.BasePagination","title":"BasePagination","text":"<p>               Bases: <code>BaseModel</code></p> <p>The pagination implementation must be a Pydantic model and implement two methods: get_limit and get_offset.</p>"},{"location":"api/pagination/pagination/#pydantic_filters.BasePagination.get_limit","title":"get_limit  <code>abstractmethod</code>","text":"<pre><code>get_limit() -&gt; int\n</code></pre> <p>Limit Getter.</p> Source code in <code>pydantic_filters/pagination/_base.py</code> <pre><code>@abstractmethod\ndef get_limit(self) -&gt; int:\n    \"\"\"Limit Getter.\"\"\"\n</code></pre>"},{"location":"api/pagination/pagination/#pydantic_filters.BasePagination.get_offset","title":"get_offset  <code>abstractmethod</code>","text":"<pre><code>get_offset() -&gt; int\n</code></pre> <p>Offset Getter.</p> Source code in <code>pydantic_filters/pagination/_base.py</code> <pre><code>@abstractmethod\ndef get_offset(self) -&gt; int:\n    \"\"\"Offset Getter.\"\"\"\n</code></pre>"},{"location":"api/pagination/pagination/#pydantic_filters.OffsetPagination","title":"OffsetPagination","text":"<p>               Bases: <code>BasePagination</code></p> <p>Limit-Offset Pagination implementation.</p>"},{"location":"api/pagination/pagination/#pydantic_filters.OffsetPagination.limit","title":"limit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>limit: int = Field(100, ge=1)\n</code></pre> <p>Limit field</p>"},{"location":"api/pagination/pagination/#pydantic_filters.OffsetPagination.offset","title":"offset  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>offset: int = Field(0, ge=0)\n</code></pre> <p>Offset field</p>"},{"location":"api/pagination/pagination/#pydantic_filters.PagePagination","title":"PagePagination","text":"<p>               Bases: <code>BasePagination</code></p> <p>Page-PerPage Pagination implementation.</p>"},{"location":"api/pagination/pagination/#pydantic_filters.PagePagination.page","title":"page  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>page: int = Field(1, ge=1)\n</code></pre> <p>Page number field</p>"},{"location":"api/pagination/pagination/#pydantic_filters.PagePagination.per_page","title":"per_page  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>per_page: int = Field(100, ge=1)\n</code></pre> <p>Items per page field</p>"},{"location":"api/plugins/fastapi/","title":"FastAPI","text":""},{"location":"api/plugins/fastapi/#pydantic_filters.plugins.fastapi.FilterDepends","title":"FilterDepends","text":"<pre><code>FilterDepends(\n    filter_: Type[_Filter], prefix: str = \"\", delimiter: str = \"__\"\n) -&gt; _Filter\n</code></pre> <p>Use this as fastapi.Depends, but for filters.</p> PARAMETER DESCRIPTION <code>filter_</code> <p>Filter class.</p> <p> TYPE: <code>Type[_Filter]</code> </p> <code>prefix</code> <p>key prefix.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>delimiter</code> <p>Delimiter for prefix and nested models.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'__'</code> </p> Source code in <code>pydantic_filters/plugins/fastapi.py</code> <pre><code>def FilterDepends(  # noqa: N802\n        filter_: Type[_Filter],\n        prefix: str = \"\",\n        delimiter: str = \"__\",\n) -&gt; _Filter:  # pragma: no cover\n    \"\"\"\n    Use this as fastapi.Depends, but for filters.\n\n    Args:\n        filter_: Filter class.\n        prefix: key prefix.\n        delimiter: Delimiter for prefix and nested models.\n    \"\"\"\n\n    def _depends(**kwargs: Any) -&gt; _Filter:  # noqa: ANN401\n        \"\"\"Signature of this function is replaced with Query parameters,\n        and kwargs contains already valid data with\n        our filters in the form of strings, which we collect into a filter object\n        \"\"\"\n        return inflate_filter(\n            filter_=filter_,\n            prefix=prefix,\n            delimiter=delimiter,\n            data=kwargs,\n        )\n\n    _depends.__signature__ = signature(_depends).replace(\n        parameters=_get_custom_params(filter_, prefix, delimiter),\n    )\n\n    return Depends(_depends)\n</code></pre>"},{"location":"api/plugins/fastapi/#pydantic_filters.plugins.fastapi.PaginationDepends","title":"PaginationDepends","text":"<pre><code>PaginationDepends(pagination: Type[_Pagination]) -&gt; _Pagination\n</code></pre> <p>Use this as fastapi.Depends, but for pagination.</p> PARAMETER DESCRIPTION <code>pagination</code> <p>Pagination class</p> <p> TYPE: <code>Type[_Pagination]</code> </p> Source code in <code>pydantic_filters/plugins/fastapi.py</code> <pre><code>def PaginationDepends(pagination: Type[_Pagination]) -&gt; _Pagination:  # pragma: no cover\n    \"\"\"\n    Use this as fastapi.Depends, but for pagination.\n\n    Args:\n        pagination: Pagination class\n    \"\"\"\n    return _PydanticModelAsDepends(pagination)\n</code></pre>"},{"location":"api/plugins/fastapi/#pydantic_filters.plugins.fastapi.SortDepends","title":"SortDepends","text":"<pre><code>SortDepends(sort: Type[_Sort]) -&gt; _Sort\n</code></pre> <p>Use this as fastapi.Depends, but for sort.</p> PARAMETER DESCRIPTION <code>sort</code> <p>Sort class.</p> <p> TYPE: <code>Type[_Sort]</code> </p> Source code in <code>pydantic_filters/plugins/fastapi.py</code> <pre><code>def SortDepends(sort: Type[_Sort]) -&gt; _Sort:  # pragma: no cover\n    \"\"\"\n    Use this as fastapi.Depends, but for sort.\n\n    Args:\n        sort: Sort class.\n    \"\"\"\n    return _PydanticModelAsDepends(sort)\n</code></pre>"},{"location":"api/sorting/sorting/","title":"Sorting","text":""},{"location":"api/sorting/sorting/#pydantic_filters.BaseSort","title":"BaseSort","text":"<p>               Bases: <code>BaseModel</code></p> <p>A base class for creating pydantic-based filters.</p>"},{"location":"api/sorting/sorting/#pydantic_filters.BaseSort.sort_by","title":"sort_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sort_by: Optional[str] = None\n</code></pre> <p>Field to sort by</p>"},{"location":"api/sorting/sorting/#pydantic_filters.BaseSort.sort_by_order","title":"sort_by_order  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sort_by_order: SortByOrder = Field(asc)\n</code></pre> <p>Sorting order</p>"},{"location":"api/sorting/sorting/#pydantic_filters.SortByOrder","title":"SortByOrder","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/sorting/sorting/#pydantic_filters.SortByOrder.asc","title":"asc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>asc = 'asc'\n</code></pre> <p>ascending</p>"},{"location":"api/sorting/sorting/#pydantic_filters.SortByOrder.desc","title":"desc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>desc = 'desc'\n</code></pre> <p>descending</p>"},{"location":"usage/fastapi/","title":"FastAPI","text":"<p><code>FastAPI</code> is a modern and fast web framework for Python.</p> <p><code>pydantic-filters</code> provides several features for integrations: <code>FilterDepends</code>,  <code>PaginationDepends</code> and  <code>SortDepends</code>. Each of the functions unpacks the pydantic model and convert <code>pydantic.FieldInfo</code>  fields to <code>fastapi.Query</code>.</p>"},{"location":"usage/fastapi/#example","title":"Example","text":"<pre><code>from enum import Enum\nfrom typing import List, Optional\n\nfrom fastapi import FastAPI\nfrom pydantic_filters import BaseFilter, BaseSort, FilterField, OffsetPagination, SearchField\nfrom pydantic_filters.plugins.fastapi import FilterDepends, PaginationDepends, SortDepends\n\n\nclass DepartmentFilter(BaseFilter):\n    chef_id: List[int] = FilterField(description=\"Here is the related field!!!\")\n\n\nclass UserFilter(BaseFilter):\n    login: List[str]\n    age__lt: int = FilterField(gt=0, le=100)\n    q: str = SearchField(target=[\"login\", \"name\", \"email\"])\n    # Related filter!\n    department: DepartmentFilter\n\n\nclass UserSortByEnum(str, Enum):\n    id = \"id\"\n    login = \"login\"\n    age = \"age\"\n\n\nclass UserSort(BaseSort):\n    sort_by: Optional[UserSortByEnum] = None\n\n\napp = FastAPI()\n\n\n@app.get(\"/users\")\nasync def get_multiple_users(\n    filter_: UserFilter = FilterDepends(UserFilter),\n    pagination: OffsetPagination = PaginationDepends(OffsetPagination),\n    sort: UserSort = SortDepends(UserSort),\n):\n    ...\n</code></pre> <p>Tip</p> <p>As of <code>FastAPI&gt;=0.115</code>,  the <code>PaginationDepends</code> and  <code>SortDepends</code> functions can be replaced by  <code>Annotated[PaginationOrSortSchema, fastapi.Query()]</code>.</p> <p></p>"},{"location":"usage/filters/","title":"Filter","text":""},{"location":"usage/filters/#introduction","title":"Introduction","text":"<p>Any web application manipulates data and pydantic models help a lot in this.  They accompany our application from validating the data in the API to serializing it in a query in the database. So pydantic models are some abstract schemas running back and forth. At least that's how I see it :)  The same way can apply in filtering: define a schema and use it.</p>"},{"location":"usage/filters/#basic-basefilter-usage","title":"Basic BaseFilter usage","text":"<p><code>BaseFilter</code> is a pydantic model.</p> <p>Let's define a user schema and filters to it:</p> <pre><code>from typing import List\n\nfrom pydantic import BaseModel\nfrom pydantic_filters import BaseFilter, SearchField\n\nclass UserSchema(BaseModel):\n    id: int\n    login: str\n    full_name: str\n    age: int\n    email: str\n    department_id: int\n\n\nclass UserFilter(BaseFilter):\n    login: List[str]\n    login__n: List[str]\n    age__lt: int\n    age__gt: int\n    department_id: List[int]\n    department_id__n: List[int]\n    q: str = SearchField(target=[\"login\", \"name\", \"email\"]) \n</code></pre> Info <p>Unlike <code>BaseModel</code>, all fields in <code>BaseFilter</code> are optional.  This is probably the only major difference between filter models and pydantic models. This behavior can be changed in the configuration, see <code>FilterConfigDict.optional</code>.</p> <p>A <code>UserFilter</code> is equivalent to the following pydantic model:</p> <pre><code>class UserFilterEquivalent(BaseModel):\n    login: List[str] = None\n    login__n: List[str] = None\n    age__lt: int = None\n    age__gt: int = None\n    department_id: List[int] = None\n    department_id__n: List[int] = None\n    q: str = None \n</code></pre> <p>Any field can be made required, you just need to add <code>Ellipsis</code>: </p> <pre><code>id: int = ...\n</code></pre> <p>There are seven filters defined in <code>UserFilter</code>:</p> <ul> <li><code>login</code> - list of include strings.</li> <li><code>login__n</code> - list of excluding strings.</li> <li><code>age__lt</code> - maximum age.</li> <li><code>age__gt</code> - minimum age.</li> <li><code>department_id</code> - list of including numbers.</li> <li><code>department_id__n</code> - list of excluding numbers.</li> <li><code>q</code> - search field by login, name or e-mail.</li> </ul> <p>The <code>UserFilter(department_id=[3, 4], age__gt=18)</code> condition will be interpreted as:</p> <p>All users over 18 years of age from department number 3 OR 4.</p> <p>As you may have already noticed, how a field will be filtered is determined  by the field suffix and the type annotation:</p> <ul> <li><code>login: str</code> ~ <code>login = value</code></li> <li><code>login: List[str]</code> ~ <code>login IN (value1, value2, ...)</code></li> <li><code>login__n: List[str]</code> ~ <code>login NOT IN (value1, value2, ...)</code></li> <li><code>age__gt: int</code> ~ <code>age &gt;= value</code></li> <li><code>age__gt: List[int]</code> ~ <code>age &gt;= value1 OR age &gt;= value2 OR ...</code></li> </ul> <p>Note</p> <p>The complete list of operators is defined in <code>FilterType</code>.</p> <p>Tip</p> <p>You can override the available suffixes and their associated operators in the model configuration <code>FilterConfigDict.suffixes_map</code>.</p>"},{"location":"usage/filters/#related-fields-filtering","title":"Related fields filtering","text":"<p>Quite often there is a need to filter on related tables in the database.  In addition to the user schema, let's define the department schema:</p> <pre><code>from typing import List\n\nfrom pydantic import BaseModel\nfrom pydantic_filters import BaseFilter, SearchField\n\nclass DepartmentSchema(BaseModel):\n    id: int\n    chef_id: int\n\n\nclass UserSchema(BaseModel):\n    id: int\n    login: str\n    full_name: str\n    age: int\n    email: str\n    department_id: int\n\n\nclass DepartmentFilter(BaseFilter):\n    chef_id: List[int]\n    chef_id__n: List[int]\n\n\nclass UserFilter(BaseFilter):\n    login: List[str]\n    login__n: List[str]\n    age__lt: int\n    age__gt: int\n    department_id: List[int]\n    department_id__n: List[int]\n    q: str = SearchField(target=[\"login\", \"full_name\", \"email\"])\n    # Related filter!\n    department: DepartmentFilter\n</code></pre> Warning <p>Support for filtering by related models depends on the driver you are using.</p> <p>For example, in the case of SQLAlchemy:</p> <pre><code>import sqlalchemy as sa\nimport sqlalchemy.orm as so\n\nclass Base(so.DeclarativeBase):\n    pass\n\n\nclass Department(Base):\n    __tablename__ = \"departments\"\n\n    id: so.Mapped[int] = so.mapped_column(primary_key=True)\n    chef_id: so.Mapped[int] = so.mapped_column(sa.ForeignKey(\"users.id\"))\n\n\nclass User(Base):\n    __tablename__ = \"users\"\n\n    id: so.Mapped[int] = so.mapped_column(primary_key=True)\n    login: so.Mapped[str]\n    full_name: so.Mapped[str]\n    age: so.Mapped[int]\n    email: so.Mapped[str]\n    department_id: so.Mapped[int] = so.mapped_column(sa.ForeignKey(\"departments.id\"))\n\n    department: so.Mapped[Department] = so.relationship(foreign_keys=\"User.department_id\")\n</code></pre> <p>Here, <code>department_id</code> is defined as a foreign key  and <code>department</code> provides access to the external table.</p>"},{"location":"usage/filters/#fields","title":"Fields","text":"<p>The <code>FilterField</code> and <code>SearchField</code>  functions are used to customize and add metadata to model fields.</p>"},{"location":"usage/filters/#target-and-type-setting","title":"Target and Type setting","text":"<p>When defining a filter for each field, the target attribute name (<code>target</code>) and the filter type (<code>type</code>) are defined.</p> <p>The following two filters are equivalents:</p> <pre><code>from typing import List\n\nfrom pydantic_filters import BaseFilter, FilterField\n\nclass CarFilter(BaseFilter):\n    color: List[str]\n    color__n: List[str]\n\n\nclass DirectCarFilter(BaseFilter):\n    color: List[str] = FilterField(target=\"color\", type_=\"eq\")\n    color__n: List[str] = FilterField(target=\"color\", type_=\"ne\")\n</code></pre> <p>But sometimes it may be necessary to name fields differently:</p> <pre><code>from typing import List\n\nfrom pydantic_filters import BaseFilter, FilterField\n\nclass DirectCarFilter(BaseFilter):\n    include_color: List[str] = FilterField(target=\"color\", type_=\"eq\")\n    exclude_color: List[str] = FilterField(target=\"color\", type_=\"ne\")\n</code></pre>"},{"location":"usage/filters/#pydantic-compatibility","title":"Pydantic compatibility","text":"<p>Both functions <code>FilterField</code> and <code>SearchField</code> are compatible with the <code>pydantic.Field</code> and will work as if the arguments were passed directly to it.</p> <pre><code>from pydantic import Field\nfrom pydantic_filters import BaseFilter, FilterField\n\nclass UserFilter(BaseFilter):\n    age__lt: int = FilterField(gt=0, le=100)\n    age__gt: int = Field(gt=0, le=100)  # The same\n</code></pre> Tip <p>The next option is also possible:</p> <pre><code>from typing import List\n\nfrom pydantic import Field\nfrom pydantic_filters import BaseFilter, FilterField\n\nclass CarFilter(BaseFilter):\n    exclude_color: List[str] = Field(\n        default=FilterField(target=\"color\", type_=\"ne\"), \n        pattern=\"^#(?:[0-9a-fA-F]{3}){1,2}$\",\n    )\n</code></pre>"},{"location":"usage/filters/#configuration","title":"Configuration","text":"<p>As in pydantic, filter behavior can be controlled using <code>FilterConfigDict</code>.</p>"},{"location":"usage/filters/#delimiter","title":"delimiter","text":"<p>Specifies the delimiter for the suffix. Defaults to <code>__</code>.</p>"},{"location":"usage/filters/#optional","title":"optional","text":"<p>By default, all fields are optional. When <code>optional = False</code> the filter behavior does not differ from <code>pydantic.BaseModel</code>.</p>"},{"location":"usage/filters/#default_filter_type","title":"default_filter_type","text":"<p>Filter type in case it cannot be \u201cguessed\u201d. The default is <code>FilterType.eq</code>.</p>"},{"location":"usage/filters/#default_search_type","title":"default_search_type","text":"<p>Search type in case it cannot be \u201cguessed\u201d.  The default is <code>SearchType.case_insensitive</code>.</p>"},{"location":"usage/filters/#suffixes_map","title":"suffixes_map","text":"<p>Map the prefix mapping to the filter type.  Defined by the function <code>get_suffixes_map</code>.</p>"},{"location":"usage/filters/#sequence_types","title":"sequence_types","text":"<p>List of types whose annotations are taken as sequences. The default is <code>(list, set)</code>.</p>"},{"location":"usage/pagination/","title":"Pagination","text":"<p>Pagination allows you to do batch selection of data from their source. The library provides two ready-to-use classes for that:</p> <ul> <li><code>OfsettPagination</code></li> <li><code>PagePagination</code></li> </ul>"},{"location":"usage/pagination/#custom-pagination","title":"Custom Pagination","text":"<p>The custom pagination class should:</p> <ul> <li>Inherit from the <code>BasePagination</code> class.</li> <li>Implement the <code>get_offset</code> and <code>get_limit</code> methods.</li> </ul>"},{"location":"usage/sort/","title":"Sort","text":"<p>Sorting determines in what order the data is selected.  There is a <code>BaseSort</code> class for this purpose.  It can be used in its \u201craw\u201d form or by adding your own metadata:</p> <pre><code>from typing import Optional\nfrom enum import Enum\n\nfrom pydantic_filters import BaseSort\n\n\nclass UserOrderByEnum(str, Enum):\n    id = \"id\"\n    login = \"login\"\n    full_name = \"full_name\"\n\n\nclass UserSort(BaseSort):\n    sort_by: Optional[UserOrderByEnum] = None\n</code></pre>"},{"location":"usage/sqlalchemy/","title":"SQLAlchemy","text":"<p><code>SQLAlchemy</code> acts as a driver for working with the database. As in any ORM, let's define the models:</p> <pre><code>import sqlalchemy as sa\nimport sqlalchemy.orm as so\n\nclass Base(so.DeclarativeBase):\n    pass\n\n\nclass Department(Base):\n    __tablename__ = \"departments\"\n\n    id: so.Mapped[int] = so.mapped_column(primary_key=True)\n    chef_id: so.Mapped[int] = so.mapped_column(sa.ForeignKey(\"users.id\"))\n\n\nclass User(Base):\n    __tablename__ = \"users\"\n\n    id: so.Mapped[int] = so.mapped_column(primary_key=True)\n    login: so.Mapped[str]\n    full_name: so.Mapped[str]\n    age: so.Mapped[int]\n    email: so.Mapped[str]\n    department_id: so.Mapped[int] = so.mapped_column(sa.ForeignKey(\"departments.id\"))\n\n    department: so.Mapped[Department] = so.relationship()\n</code></pre>"},{"location":"usage/sqlalchemy/#filter","title":"Filter","text":"<p>Define filters and use <code>append_filter_to_statement</code>:</p> <pre><code>from typing import List\n\nfrom pydantic_filters import BaseFilter, SearchField\n\n\nclass DepartmentFilter(BaseFilter):\n    chef_id: List[int]\n\n\nclass UserFilter(BaseFilter):\n    login: List[str]\n    age__lt: int\n    department_id: List[int]\n    q: str = SearchField(target=[\"login\", \"full_name\"])\n    department: DepartmentFilter\n</code></pre>"},{"location":"usage/sqlalchemy/#simple-filtration","title":"Simple filtration","text":"<pre><code>from pydantic_filters.drivers.sqlalchemy import append_filter_to_statement\n\nstmt = append_filter_to_statement(\n    statement=sa.select(User),\n    model=User,\n    filter_=UserFilter(login=[\"alice\", \"bob\"], q=\"Eva\"),\n)\nprint(stmt)\n</code></pre> <pre><code>SELECT users.id, users.login, users.full_name, users.age, users.department_id\nFROM users \nWHERE users.login IN ('alice', 'bob') \n  AND (users.login ILIKE '%Eva%' OR users.full_name ILIKE '%Eva%')\n</code></pre>"},{"location":"usage/sqlalchemy/#joined-filtration","title":"Joined filtration","text":"<p>Almost the same thing:</p> <pre><code>stmt = append_filter_to_statement(\n    statement=sa.select(User),\n    model=User,\n    filter_=UserFilter(login=[\"alice\", \"bob\"], department=DepartmentFilter(chef_id=[5])),\n)\nprint(stmt)\n</code></pre> <pre><code>SELECT users.id, users.login, users.full_name, users.age, users.department_id \nFROM users \n    JOIN departments AS departments_1 \n        ON users.department_id = departments_1.id AND departments_1.chef_id IN (5) \nWHERE users.login IN ('alice', 'bob')\n</code></pre> <p>Note</p> <p>It should be noted that joined tables will not be included in the final result. You can use <code>sqlalchemy.orm.joinedload()</code> to get a second join:</p> <pre><code>stmt = append_filter_to_statement(\n    statement=sa.select(User),\n    model=User,\n    filter_=UserFilter(login=[\"alice\", \"bob\"], department=DepartmentFilter(chef_id=[5])),\n)\nstmt = stmt.options(so.joinedload(User.department))\nprint(stmt)\n</code></pre> <pre><code>SELECT users.id, users.login, users.full_name, users.age, users.department_id, departments_1.id AS id_1, departments_1.chef_id \nFROM users \n    JOIN departments AS departments_2 \n        ON users.department_id = departments_2.id AND departments_2.chef_id IN (5) \n    LEFT OUTER JOIN departments AS departments_1 ON departments_1.id = users.department_id \nWHERE users.login IN ('alice', 'bob')\n</code></pre>"},{"location":"usage/sqlalchemy/#get-count","title":"Get count","text":"<p>You can also get a statement to get the number of rows satisfying the filter by using the function <code>get_count_statement()</code>:</p> <pre><code>from pydantic_filters.drivers.sqlalchemy import get_count_statement\n\ncount_stmt = get_count_statement(\n    model=User,\n    filter_=UserFilter(login=[\"alice\", \"bob\"], department=DepartmentFilter(chef_id=[5])),\n)\nprint(count_stmt)\n</code></pre> <pre><code>SELECT count(DISTINCT users.id) AS count_1 \nFROM users \n    JOIN departments AS departments_1 \n        ON users.department_id = departments_1.id AND departments_1.chef_id IN (5) \nWHERE users.login IN ('alice', 'bob')\n</code></pre>"},{"location":"usage/sqlalchemy/#pagination","title":"Pagination","text":"<p>There is a similar function for pagination  <code>append_pagination_to_statement()</code>:</p> <pre><code>from pydantic_filters import OffsetPagination\nfrom pydantic_filters.drivers.sqlalchemy import append_pagination_to_statement\n\nstmt = append_pagination_to_statement(\n    statement=sa.select(User),\n    pagination=OffsetPagination(limit=1000, offset=4000),\n)\nprint(stmt)\n</code></pre> <pre><code>SELECT users.id, users.login, users.full_name, users.age, users.department_id \nFROM users \nLIMIT 1000 OFFSET 4000\n</code></pre>"},{"location":"usage/sqlalchemy/#sort","title":"Sort","text":"<p>And for Sort <code>append_sort_to_statement()</code>:</p> <pre><code>from pydantic_filters import BaseSort, SortByOrder\nfrom pydantic_filters.drivers.sqlalchemy import append_sort_to_statement\n\nstmt = append_sort_to_statement(\n    statement=sa.select(User),\n    model=User,\n    sort=BaseSort(sort_by=\"login\", sort_by_order=SortByOrder.desc),\n)\nprint(stmt)\n</code></pre> <pre><code>SELECT users.id, users.login, users.full_name, users.age, users.department_id \nFROM users \nORDER BY users.login DESC\n</code></pre>"},{"location":"usage/sqlalchemy/#all-in-one","title":"All in one","text":"<p><code>append_to_statement()</code> - all-in-one function:</p> <pre><code>from pydantic_filters.drivers.sqlalchemy import append_to_statement\n\nstmt = append_to_statement(\n    statement=sa.select(User),\n    model=User,\n    filter_=UserFilter(q=\"Eva\"),\n    pagination=OffsetPagination(limit=10),\n    sort=BaseSort(sort_by=\"login\"),\n)\nprint(stmt)\n</code></pre> <pre><code>SELECT users.id, users.login, users.full_name, users.age, users.department_id \nFROM users \nWHERE users.login ILIKE '%%Eva%%' OR users.full_name ILIKE '%%Eva%%' \nORDER BY users.login ASC \nLIMIT 10 OFFSET 0\n</code></pre>"}]}